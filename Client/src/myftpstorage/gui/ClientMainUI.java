/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package myftpstorage.gui;

import java.awt.Cursor;
import java.awt.Toolkit;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.rmi.RemoteException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JProgressBar;
import javax.swing.JTree;
import javax.swing.SwingWorker;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import myftpstorage.remoteInt.ServerInt;
import myftpstorage.util.ReadConfig;

/**
 *
 * @author dat
 */
public class ClientMainUI extends javax.swing.JFrame {

    /**
     * Creates new form ClientMainUI
     */
    private static final String CONFIG_PATH = "config_file";

    private int SPEED;
    private ServerInt SERVER;
    private String USERNAME;
    private UploadTask UPTASK;
    private DownloadTask DOWNTASK;

    public ClientMainUI(ServerInt server, String userName) throws RemoteException {
        HashMap config = ReadConfig.readConfig(CONFIG_PATH);
        this.SPEED = (int) config.get("network_speed");
        this.SERVER = server;
        this.USERNAME = userName;
        initComponents();
        myInitComp(server.getDirTree(userName));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        btnCreateDir = new javax.swing.JButton();
        btnUpload = new javax.swing.JButton();
        btnDownload = new javax.swing.JButton();
        btnDelete = new javax.swing.JButton();
        btnUpPause = new javax.swing.JButton();
        btnUpResume = new javax.swing.JButton();
        btnUpStop = new javax.swing.JButton();
        btnDownPause = new javax.swing.JButton();
        btnDownResume = new javax.swing.JButton();
        btnDownStop = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        edDirName = new javax.swing.JTextField();
        lbHint = new javax.swing.JLabel();
        lbUpFileName = new javax.swing.JLabel();
        lbDownFileName = new javax.swing.JLabel();
        spDownload = new javax.swing.JScrollPane();
        spUpload = new javax.swing.JScrollPane();

        jLabel4.setText("jLabel4");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        btnCreateDir.setText("Create Dir");
        btnCreateDir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCreateDirActionPerformed(evt);
            }
        });

        btnUpload.setText("Upload");
        btnUpload.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUploadActionPerformed(evt);
            }
        });

        btnDownload.setText("Download");
        btnDownload.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownloadActionPerformed(evt);
            }
        });

        btnDelete.setText("Delete");
        btnDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDeleteActionPerformed(evt);
            }
        });

        btnUpPause.setText("Pause");
        btnUpPause.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUpPauseActionPerformed(evt);
            }
        });

        btnUpResume.setText("Resume");
        btnUpResume.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUpResumeActionPerformed(evt);
            }
        });

        btnUpStop.setText("Stop");
        btnUpStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnUpStopActionPerformed(evt);
            }
        });

        btnDownPause.setText("Pause");
        btnDownPause.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownPauseActionPerformed(evt);
            }
        });

        btnDownResume.setText("Resume");
        btnDownResume.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownResumeActionPerformed(evt);
            }
        });

        btnDownStop.setText("Stop");
        btnDownStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownStopActionPerformed(evt);
            }
        });

        jLabel1.setText("Download :");

        jLabel2.setText("Your Storage:");

        jLabel5.setText("Upload:");

        edDirName.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                edDirNameActionPerformed(evt);
            }
        });

        lbHint.setForeground(new java.awt.Color(255, 0, 0));

        lbUpFileName.setText("FilePath");

        lbDownFileName.setText("FilePath");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lbHint, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(241, 241, 241))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 373, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(btnCreateDir)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(edDirName, javax.swing.GroupLayout.PREFERRED_SIZE, 264, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(btnUpload)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnDownload)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnDelete)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(17, 17, 17)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel1)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(3, 3, 3)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(lbUpFileName)
                                            .addComponent(jLabel5)))))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(lbDownFileName))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(btnUpPause)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnUpResume)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(btnUpStop))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(spUpload, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(btnDownPause)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(btnDownResume)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(btnDownStop))
                                    .addComponent(spDownload, javax.swing.GroupLayout.PREFERRED_SIZE, 270, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                .addContainerGap(17, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(4, 4, 4)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(40, 40, 40)
                        .addComponent(lbUpFileName)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(spUpload, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnUpPause)
                            .addComponent(btnUpResume)
                            .addComponent(btnUpStop))
                        .addGap(103, 103, 103)
                        .addComponent(jLabel1)
                        .addGap(34, 34, 34)
                        .addComponent(lbDownFileName)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(spDownload, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnDownPause)
                            .addComponent(btnDownResume)
                            .addComponent(btnDownStop)))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnCreateDir)
                    .addComponent(edDirName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnUpload)
                    .addComponent(btnDownload)
                    .addComponent(btnDelete))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lbHint)
                .addContainerGap(25, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnDownloadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownloadActionPerformed
        if (this.tree.isSelectionEmpty()) {
            this.lbHint.setText("Chosing a file first!");
        } else {
            String souPath = this.getSelectPath();
            try {
                File souFile = SERVER.getFileProperty(souPath);
                if (souFile.isDirectory()) {
                    this.lbHint.setText("Chosing a file not a directory!");
                } else {
                    JFileChooser fc = new JFileChooser();
                    int check = fc.showSaveDialog(this);
                    if (check == JFileChooser.APPROVE_OPTION) {
                        this.lbHint.setText("");

// ===========> Sloving Conflict
                        File desFile = fc.getSelectedFile();
                        int flat = 1;
                        if(desFile.exists()){
                            Date date = new Date(desFile.lastModified());
                            DateFormat formatter = new SimpleDateFormat("MMMMM.dd - HH:mm");
                            String oldModify = formatter.format(date);
                            
                            date = new Date(souFile.lastModified());
                            String newModify = formatter.format(date);
                            int result = JOptionPane.showConfirmDialog(this,
                                    "Do you want to replace oldfile["+ oldModify +"] by newfile["+ newModify +"]?",
                                    "Uploading Confirm", JOptionPane.INFORMATION_MESSAGE);
                            if(result != JOptionPane.OK_OPTION){
                                flat = 0;
                                SERVER.writeLog(USERNAME + ": Cancel to download [" + souFile.getName() +"] file.\n");
                            }else{
                                SERVER.writeLog(USERNAME + ": Override the old file [" + desFile.getName() +"].\n");
                            }
                        }
                        
                        if(flat == 1){
                            SERVER.initDownload(souPath);
                            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                            String fileName = souPath.substring(souPath.lastIndexOf("/") + 1, souPath.length());
                            this.lbDownFileName.setText(fileName);

                            File file = fc.getSelectedFile();
                            DOWNTASK = new DownloadTask(file.getPath());
                            DOWNTASK.execute();

                            btnDownPause.setEnabled(true);
                            btnDownResume.setEnabled(false);
                            btnDownStop.setEnabled(true);
                        }
                        
                    } else {
                        this.lbHint.setText("Chosing local dir has been failed!");
                    }
                }
            } catch (RemoteException ex) {
                Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                this.lbHint.setText("Conecting error!");
            } catch (FileNotFoundException ex) {
                Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                this.lbHint.setText("Error local dir NOT found!");

            }
        }
    }//GEN-LAST:event_btnDownloadActionPerformed

    private void btnCreateDirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCreateDirActionPerformed
        if (!this.tree.isSelectionEmpty()) {
            String dirName = this.edDirName.getText();
            if (dirName.equals("")) {
                this.lbHint.setText("Please enter Directory's name!");
            } else if (dirName.contains("(") || dirName.contains(")")
                    || dirName.contains("!") || dirName.contains(".")
                    || dirName.contains("%") || dirName.contains("#") || dirName.contains("^")
                    || dirName.contains("&") || dirName.contains("$") || dirName.contains("@")) {
                this.lbHint.setText("Directory's name has special symbol!");
            } else {
                try {
                    if (this.SERVER.createDir(this.getSelectPath() + "/" + dirName.trim())) {
                        this.addTreeNode(dirName.trim());
                        this.lbHint.setText("");
                    } else {
                        this.lbHint.setText("Directory's name already been used!");
                    }
                } catch (RemoteException ex) {
                    Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                    this.lbHint.setText("Connect errors");
                }
            }
        } else {
            this.lbHint.setText("Please select Parent Directory first!");
        }

    }//GEN-LAST:event_btnCreateDirActionPerformed

    private void btnUploadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUploadActionPerformed
        if (this.tree.isSelectionEmpty()) {
            this.lbHint.setText("Chosing a directory to upload first!");
        } else {
            String desPath = this.getSelectPath();
            try {
                File desDir = SERVER.getFileProperty(desPath);
                if (desDir.isDirectory()) {
                    JFileChooser fc = new JFileChooser();
                    int check = fc.showOpenDialog(this);
                    if (check == JFileChooser.APPROVE_OPTION) {
                        this.lbHint.setText("");

                        File souFile = fc.getSelectedFile();
                        File desFile = SERVER.getFileProperty(desPath + "/" + souFile.getName());
// ===========> Sloving Conflict
                        int flat = 1;
                        if(desFile.exists()){
                            Date date = new Date(desFile.lastModified());
                            DateFormat formatter = new SimpleDateFormat("MMMMM.dd - HH:mm");
                            String oldModify = formatter.format(date);
                            
                            date = new Date(souFile.lastModified());
                            String newModify = formatter.format(date);
                            int result = JOptionPane.showConfirmDialog(this,
                                    "Do you want to replace oldfile["+ oldModify +"] by newfile["+ newModify +"]?",
                                    "Uploading Confirm", JOptionPane.INFORMATION_MESSAGE);
                            if(result != JOptionPane.OK_OPTION){
                                flat = 0;
                                SERVER.writeLog(USERNAME + ": Cancel to upload [" + souFile.getName() +"] file.\n");
                            }else{
                                SERVER.writeLog(USERNAME + ": Override the old file [" + desFile.getName() +"].\n");
                            }
                        }
                        
                        if(flat == 1){
                                SERVER.initUpload(desPath + "/" + souFile.getName());
                                setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                                this.lbUpFileName.setText(souFile.getName() + " (" + souFile.length() / 1024 + "KB)");

                                UPTASK = new UploadTask(souFile.getPath());
                                UPTASK.execute();

                                btnUpPause.setEnabled(true);
                                btnUpResume.setEnabled(false);
                                btnUpStop.setEnabled(true);
                            }
                    } else {
                        this.lbHint.setText("Chosing local file has been failed!");
                    }
                } else {
                    this.lbHint.setText("Chosing a directory not a file!");
                }
            } catch (RemoteException ex) {
                Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                this.lbHint.setText("Server connect gets an error!");
            } catch (FileNotFoundException ex) {
                Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                this.lbHint.setText("Source file NOT found error!");

            }
        }
    }//GEN-LAST:event_btnUploadActionPerformed

    private void btnUpResumeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUpResumeActionPerformed
        try {
            this.UPTASK = new UploadTask(this.upPauseState);
            this.UPTASK.execute();
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            btnUpPause.setEnabled(true);
            btnUpResume.setEnabled(false);
            btnUpStop.setEnabled(true);
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            this.lbHint.setText("Server connecting gets error!");
        }
    }//GEN-LAST:event_btnUpResumeActionPerformed

    private void btnDownResumeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownResumeActionPerformed
        try {
            this.DOWNTASK = new DownloadTask(this.downPauseState);
            this.DOWNTASK.execute();
            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            btnDownPause.setEnabled(true);
            btnDownResume.setEnabled(false);
            btnDownStop.setEnabled(true);
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            this.lbHint.setText("Server connecting gets error!");
        }
    }//GEN-LAST:event_btnDownResumeActionPerformed

    private void btnDownStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownStopActionPerformed
        try {
            this.DOWNTASK.stop();
            btnDownPause.setEnabled(false);
            btnDownResume.setEnabled(false);
            btnDownStop.setEnabled(false);
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            this.lbHint.setText("Error to stop!");

        }
    }//GEN-LAST:event_btnDownStopActionPerformed

    private void edDirNameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_edDirNameActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_edDirNameActionPerformed

    private void btnDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDeleteActionPerformed
        int result = JOptionPane.showConfirmDialog(this, "Are you sure to delete that file/directory?", "Deleting Confirm", JOptionPane.INFORMATION_MESSAGE);
        if (result == JOptionPane.OK_OPTION){
            try {
                String selectPath = this.getSelectPath();
                if(SERVER.deleteFile(selectPath)){
                    SERVER.writeLog(USERNAME + ": Delete [" + 
                            selectPath.substring(selectPath.lastIndexOf("/") + 1, selectPath.length()) + "]\n");
                    removeCurTreeNode();
                    this.lbHint.setText("Deleting done!");
                }else{
                    this.lbHint.setText("Directory musts be empty!");
                }
            } catch (RemoteException ex) {
                Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                this.lbHint.setText("Connecting gets an error");
            }
        }
    }//GEN-LAST:event_btnDeleteActionPerformed

    private void btnUpPauseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUpPauseActionPerformed
        try {
            this.upPauseState = this.UPTASK.pause();
            btnUpPause.setEnabled(false);
            btnUpResume.setEnabled(true);
            btnUpStop.setEnabled(true);
            setCursor(null);
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            this.lbHint.setText("Error to resume!");

        }
    }//GEN-LAST:event_btnUpPauseActionPerformed

    private void btnDownPauseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownPauseActionPerformed
        try {
            this.downPauseState = this.DOWNTASK.pause();
            btnDownPause.setEnabled(false);
            btnDownResume.setEnabled(true);
            btnDownStop.setEnabled(true);
            setCursor(null);
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            this.lbHint.setText("Error to pause!");

        }
    }//GEN-LAST:event_btnDownPauseActionPerformed

    private void btnUpStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnUpStopActionPerformed
        try {
            this.UPTASK.stop();
            btnUpPause.setEnabled(false);
            btnUpResume.setEnabled(false);
            btnUpStop.setEnabled(false);
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            this.lbHint.setText("Error to stop!");
        }
        
    }//GEN-LAST:event_btnUpStopActionPerformed

    protected DefaultMutableTreeNode rootNode;
    protected DefaultTreeModel treeModel;
    protected JTree tree;
    private Toolkit toolkit = Toolkit.getDefaultToolkit();
    private JProgressBar pbUpload;
    private JProgressBar pbDownload;
    private HashMap upPauseState;
    private HashMap downPauseState;


    private void myInitComp(HashMap dirTree) {
        rootNode = new DefaultMutableTreeNode(this.USERNAME);
        treeModel = new DefaultTreeModel(rootNode);

        treeModel.addTreeModelListener(new TreeModelListener() {
            @Override
            public void treeNodesChanged(TreeModelEvent e) {
            }

            @Override
            public void treeNodesInserted(TreeModelEvent e) {
            }

            @Override
            public void treeNodesRemoved(TreeModelEvent e) {
            }

            @Override
            public void treeStructureChanged(TreeModelEvent e) {
            }
        });
        tree = new JTree(treeModel);
        tree.setEditable(false);
        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        tree.setShowsRootHandles(true);
        this.addDirTree(dirTree, null);
        jScrollPane1.setViewportView(tree);

        btnUpPause.setEnabled(false);
        btnUpResume.setEnabled(false);
        btnUpStop.setEnabled(false);

        btnDownPause.setEnabled(false);
        btnDownResume.setEnabled(false);
        btnDownStop.setEnabled(false);

        pbUpload = new JProgressBar(0, 100);
        pbUpload.setValue(0);
        pbUpload.setStringPainted(true);
        spUpload.setViewportView(pbUpload);

        pbDownload = new JProgressBar(0, 100);
        pbDownload.setValue(0);
        pbDownload.setStringPainted(true);
        spDownload.setViewportView(pbDownload);
    }

    private String getSelectPath() {
        try {
            String userRootPath = this.SERVER.getUserRootPath(this.USERNAME);
            TreePath selectPath = this.tree.getSelectionPath();
            ArrayList<Object> temp = new ArrayList<>();
            while (selectPath.getParentPath() != null) {
                temp.add(selectPath.getLastPathComponent());
                selectPath = selectPath.getParentPath();
            }
            for (int i = temp.size() - 1; i >= 0; i--) {
                userRootPath += "/" + temp.get(i);
            }
            if (userRootPath.contains("(")) {
                return userRootPath.substring(0, userRootPath.lastIndexOf("(")).trim();
            } else {
                return userRootPath.trim();
            }
        } catch (RemoteException ex) {
            Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
            return null;
        }

    }

    private void addDirTree(HashMap dirTree, DefaultMutableTreeNode root) {
        dirTree.forEach((key, value) -> {
            DefaultMutableTreeNode parent = this.addTreeNode(root, key);
            if (value != null) {
                this.addDirTree((HashMap) value, parent);
            }
        });
    }

    /**
     * Remove all nodes except the root node.
     */
    private void clearTree() {
        rootNode.removeAllChildren();
        treeModel.reload();
    }

    /**
     * Remove the currently selected node.
     */
    private void removeCurTreeNode() {
        TreePath currentSelection = tree.getSelectionPath();
        if (currentSelection != null) {
            DefaultMutableTreeNode currentNode = (DefaultMutableTreeNode) (currentSelection.getLastPathComponent());
            MutableTreeNode parent = (MutableTreeNode) (currentNode.getParent());
            if (parent != null) {
                treeModel.removeNodeFromParent(currentNode);
                return;
            }
        }

        // Either there was no selection, or the root was selected.
        toolkit.beep();
    }

    /**
     * Add child to the currently selected node.
     */
    private DefaultMutableTreeNode addTreeNode(Object child) {
        DefaultMutableTreeNode parentNode = null;
        TreePath parentPath = tree.getSelectionPath();

        if (parentPath == null) {
            parentNode = rootNode;
        } else {
            parentNode = (DefaultMutableTreeNode) (parentPath.getLastPathComponent());
        }

        return addTreeNode(parentNode, child, true);
    }

    private DefaultMutableTreeNode addTreeNode(DefaultMutableTreeNode parent,
            Object child) {
        return addTreeNode(parent, child, false);
    }

    private DefaultMutableTreeNode addTreeNode(DefaultMutableTreeNode parent,
            Object child,
            boolean shouldBeVisible) {
        DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(child);

        if (parent == null) {
            parent = rootNode;
        }

        //It is key to invoke this on the TreeModel, and NOT DefaultMutableTreeNode
        treeModel.insertNodeInto(childNode, parent, parent.getChildCount());

        //Make sure the user can see the lovely new node.
        if (shouldBeVisible) {
            tree.scrollPathToVisible(new TreePath(childNode.getPath()));
        }
        return childNode;
    }

    /**
     * @param args the command line arguments
     */

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCreateDir;
    private javax.swing.JButton btnDelete;
    private javax.swing.JButton btnDownPause;
    private javax.swing.JButton btnDownResume;
    private javax.swing.JButton btnDownStop;
    private javax.swing.JButton btnDownload;
    private javax.swing.JButton btnUpPause;
    private javax.swing.JButton btnUpResume;
    private javax.swing.JButton btnUpStop;
    private javax.swing.JButton btnUpload;
    private javax.swing.JTextField edDirName;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lbDownFileName;
    private javax.swing.JLabel lbHint;
    private javax.swing.JLabel lbUpFileName;
    private javax.swing.JScrollPane spDownload;
    private javax.swing.JScrollPane spUpload;
    // End of variables declaration//GEN-END:variables

    class UploadTask extends SwingWorker<Void, Void> {

        private int numCurSeg;
        private int totalNumSeg;
        private int state;
        private InputStream inStream;
        private File file;

        public UploadTask(String sourcePath) throws FileNotFoundException, RemoteException {
            this.state = 1;
            this.numCurSeg = 0;
            this.file = new File(sourcePath);
            this.totalNumSeg = (int) (file.length() / SPEED);
            this.inStream = new FileInputStream(sourcePath);
            SERVER.writeLog(USERNAME + ": Starting uploads [" + this.file.getName() + "] file.\n");
            setProgress(0);
            addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt) {
                    if ("progress" == evt.getPropertyName()) {
                        int progress = (Integer) evt.getNewValue();
                        pbUpload.setValue(progress);
                    }
                }
            });
        }
        
        public UploadTask(HashMap prePauseState) throws RemoteException {
            this.state = 1;
            this.numCurSeg = (int) prePauseState.get("current_seg");
            this.totalNumSeg = (int) prePauseState.get("total_seg");
            this.inStream = (InputStream) prePauseState.get("input_stream");
            this.file = (File) prePauseState.get("source_file");
            SERVER.writeLog(USERNAME + ": Resuming uploads [" + this.file.getName() + "] file.\n");

            addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt) {
                    if ("progress" == evt.getPropertyName()) {
                        int progress = (Integer) evt.getNewValue();
                        pbUpload.setValue(progress);
                    }
                }
            });
        }

        @Override
        protected Void doInBackground() throws Exception {
            byte[] buffer = new byte[SPEED];
            int readedSize;
            Random random = new Random();
            int progress;
//            System.out.println("Total Seg: " + this.totalNumSeg);

            //Initialize progress property.
            while (this.state == 1 && (readedSize = this.inStream.read(buffer, 0, SPEED)) >= 0) {
//                System.out.println("CurentSeg: " + this.numCurSeg);
                if (readedSize < SPEED) {
                    byte[] endSeg = new byte[readedSize];
                    System.arraycopy(buffer, 0, endSeg, 0, readedSize);
                    SERVER.write(endSeg);
                } else {
                    SERVER.write(buffer);
                }
                //Sleep for up to one second.
                try {
                    Thread.sleep(random.nextInt(1500));
                } catch (InterruptedException ignore) {
                }
                //Make random progress.
                progress = (int) this.numCurSeg * 100 / this.totalNumSeg;
                setProgress(Math.min(progress, 100));
                this.numCurSeg += 1;
            }

            return null;
        }

        @Override
        protected void done() {
            if (this.state != 2) {
                btnUpload.setEnabled(true);
                btnUpPause.setEnabled(false);
                btnUpResume.setEnabled(false);
                btnUpStop.setEnabled(false);
                setCursor(null); //turn off the wait cursor
                if (this.state == 1) {
                    try {
                        SERVER.writeLog(USERNAME + ": Finish uploads [" + this.file.getName() + "] file.\n");
                    } catch (RemoteException ex) {
                        Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                    }

                    lbHint.setText("Uploading done!");
                    Date date = new Date(this.file.lastModified());
                    DateFormat formatter = new SimpleDateFormat("MMMMM.dd - HH:mm");
                    String lastModi = formatter.format(date);
                    addTreeNode("[New]"+this.file.getName() + " (" + this.file.length() / 1024 + "KB - " + lastModi + ")");

                }
            }
        }

        public HashMap pause() throws RemoteException {
            SERVER.writeLog(USERNAME + ": Uploading [" + this.file.getName() + "] file gets PAUSE.\n");

            this.state = 2;
            HashMap prePauseState = new HashMap();
            prePauseState.put("current_seg", this.numCurSeg+1);
            prePauseState.put("total_seg", this.totalNumSeg);
            prePauseState.put("input_stream", this.inStream);
            prePauseState.put("source_file", this.file);
            return prePauseState;
        }

        public void stop() throws RemoteException {
            SERVER.writeLog(USERNAME + ": Uploading [" + this.file.getName() + "] file gets STOP.\n");
            this.state = 0;
        }
    }
    
    class DownloadTask extends SwingWorker<Void, Void> {
        
        private int numCurSeg;
        private int totalNumSeg;
        private int state;
        private OutputStream outStream;
        private File file;

        public DownloadTask(String desPath) throws RemoteException, FileNotFoundException {
            this.state = 1;
            this.numCurSeg = 0;
            this.file = SERVER.getFileProperty(getSelectPath());
            this.totalNumSeg = (int) (file.length() / SPEED);
            this.outStream = new FileOutputStream(desPath);
            SERVER.writeLog(USERNAME + ": Starting downloads [" + this.file.getName() + "] file.\n");

            setProgress(0);
            addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt) {
                    if ("progress" == evt.getPropertyName()) {
                        int progress = (Integer) evt.getNewValue();
                        pbDownload.setValue(progress);
                    }
                }
            });
        }
        
        public DownloadTask(HashMap prePauseState) throws RemoteException {
            this.state = 1;
            this.numCurSeg = (int) prePauseState.get("current_seg");
            this.totalNumSeg = (int) prePauseState.get("total_seg");
            this.outStream = (OutputStream) prePauseState.get("output_stream");
            this.file = (File) prePauseState.get("des_file");
            SERVER.writeLog(USERNAME + ": Resuming downloads [" + this.file.getName() + "] file.\n");
            addPropertyChangeListener(new PropertyChangeListener() {
                @Override
                public void propertyChange(PropertyChangeEvent evt) {
                    if ("progress" == evt.getPropertyName()) {
                        int progress = (Integer) evt.getNewValue();
                        pbDownload.setValue(progress);
                    }
                }
            });
        }

        @Override
        protected Void doInBackground() throws Exception {
            byte[] buffer;

            Random random = new Random();
            int progress;
//            System.out.println("Total Seg: " + this.totalNumSeg);

            //Initialize progress property.
            while (this.state == 1 && (buffer = SERVER.read()) != null) {
//                System.out.println("CurentSeg: " + this.numCurSeg);
                this.outStream.write(buffer);
                this.numCurSeg++;
                //Sleep for up to one second.
                try {
                    Thread.sleep(random.nextInt(1500));
                } catch (InterruptedException ignore) {
                }
                //Make random progress.
                progress = (int) this.numCurSeg * 100 / this.totalNumSeg;
                setProgress(Math.min(progress, 100));
                this.numCurSeg += 1;
            }
            return null;
        }

        @Override
        protected void done() {
            if (this.state != 2) {
                btnDownload.setEnabled(true);
                btnDownPause.setEnabled(false);
                btnDownResume.setEnabled(false);
                btnDownStop.setEnabled(false);
                setCursor(null); //turn off the wait cursor
                if (this.state == 1) {
                    try {
                        SERVER.writeLog(USERNAME + ": Finish downloads [" + this.file.getName() + "] file.\n");
                    } catch (RemoteException ex) {
                        Logger.getLogger(ClientMainUI.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    lbHint.setText("Downloading done!");
                }
            }
        }

        public HashMap pause() throws RemoteException {
            SERVER.writeLog(USERNAME + ": Downloading [" + this.file.getName() + "] file gets PAUSE.\n");

            this.state = 2;
            HashMap prePauseState = new HashMap();
            prePauseState.put("current_seg", this.numCurSeg+1);
            prePauseState.put("total_seg", this.totalNumSeg);
            prePauseState.put("output_stream", this.outStream);
            prePauseState.put("des_file", this.file);
            return prePauseState;
        }

        public void stop() throws RemoteException {
            SERVER.writeLog(USERNAME + ": Downloading [" + this.file.getName() + "] file gets STOP.\n");
            this.state = 0;
        }
    }

}
